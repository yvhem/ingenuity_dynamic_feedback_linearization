function dxi_ext = ingenuity_closed_loop(t, xi_ext, p, trajectory_type)
    % extended state
    P = xi_ext(1:3);
    V_b = xi_ext(4:6);
    Theta = xi_ext(7:9); % [phi; theta; psi]
    phi = Theta(1); theta = Theta(2); psi = Theta(3);
    omega = xi_ext(10:12);
    
    % controller state
    F_T = xi_ext(13);
    F_T_dot = xi_ext(14);

    %% reference trajectory
    ref = traj_utils(t, trajectory_type);
    
    %% Kinematics and Matrices
    
    cph = cos(phi); sph = sin(phi);
    cth = cos(theta); sth = sin(theta);
    cps = cos(psi); sps = sin(psi);
    
    % Rotation matrix
    R = [cps*cth, cps*sth*sph - sps*cph, cps*sth*cph + sps*sph;
         sps*cth, sps*sth*sph + cps*cph, sps*sth*cph - cps*sph;
         -sth,    cth*sph,                cth*cph];


    % W -> Euler rates
    W_mat = [1, sph*sth/cth, cph*sth/cth;
             0, cph,         -sph;
             0, sph/cth,     cph/cth];
    Theta_dot_current = W_mat * omega;
    phi_dot = Theta_dot_current(1); 
    W_row3 = W_mat(3, :);
    
    %% Preliminary dynamics
    F_thrust_b = [0; 0; F_T];
    F_drag_b = -p.A_trans * V_b;
    F_gravity_b = R' * [0; 0; -p.m * p.g];
    
    F_tot_b = F_thrust_b + F_drag_b + F_gravity_b;
    V_b_dot_current = (1/p.m) * F_tot_b - cross(omega, V_b);

    %% Virtual control (nu)
    % 1. Position channel

    P_dot = R * V_b;
    
    % Acceleration 
    P_ddot = (1/p.m) * (R * [0;0;F_T] + R*F_drag_b) + [0;0;-p.g];
    
    % Jerk
    e3 = [0;0;1];
    omega_skew = [0 -omega(3) omega(2); omega(3) 0 -omega(1); -omega(2) omega(1) 0];
    
    % Derivative of drag
    F_drag_dot_b = -p.A_trans * V_b_dot_current;
    
    % Jerk components: Thrust Jerk + Drag Jerk
    term_thrust_jerk = (1/p.m) * (F_T_dot * R * e3 + F_T * R * omega_skew * e3);
    term_drag_jerk   = (1/p.m) * R * (cross(omega, F_drag_b) + F_drag_dot_b);
    
    P_dddot = term_thrust_jerk + term_drag_jerk; 

    % Errors
    e_p = ref.pos - P;
    e_v = ref.vel - P_dot;
    e_a = ref.acc - P_ddot;
    e_j = ref.jerk - P_dddot;
    
    % Pos virtual input
    nu_pos = ref.snap + p.kp(4)*e_j + p.kp(3)*e_a + p.kp(2)*e_v + p.kp(1)*e_p;
    
    % 2. Psi channel

    psi_dot = W_row3 * omega;

    % Errors
    e_psi = psi - ref.psi;
    e_psi_dot = psi_dot - ref.psi_dot;
    
    % Yaw virtual input
    nu_psi = ref.psi_ddot - (p.kpsi(2)*e_psi_dot + p.kpsi(1)*e_psi);
    
    nu = [nu_pos; nu_psi];

    %% Dynamic Feedback Linearization
    
    % 1. Decoupling Matrix J
    J11 = (1/p.m) * R * e3;
    e3_skew = [0 -1 0; 1 0 0; 0 0 0];
    J12 = -(F_T/p.m) * R * e3_skew * p.invI;
    J21 = 0;
    J22 = W_row3 * p.invI;
    
    J_mat = [J11, J12; 
             J21, J22];
             
    % 2. Drift vector l

    % 2.1 Yaw drift

    q = omega(2); r = omega(3);
    term1 = (q*cph - r*sph)*phi_dot/cth;
    term2 = (q*sph + r*cph)*(sth/cth^2)*(q*cph - r*sph); 
    W_dot_omega = term1 + term2; 
    
    tau_drag = -p.A_rot * omega;
    gyro = cross(omega, p.I * omega);
    omega_dot_drift = p.invI * (tau_drag - gyro);
    
    l_psi = W_dot_omega + W_row3 * omega_dot_drift;
    
    % 2.2 Position Drift

    % analytically deriving the full Snap drift for drag terms is complex
    % We ignore the derivation for the drag component assuming that
    % the change in drag is negligible
    
    term_coriolis = (2 * F_T_dot / p.m) * R * omega_skew * e3;
    term_centrifugal = (F_T / p.m) * R * (omega_skew * omega_skew) * e3;
    
    omega_dot_drift_skew = [0 -omega_dot_drift(3) omega_dot_drift(2); omega_dot_drift(3) 0 -omega_dot_drift(1); -omega_dot_drift(2) omega_dot_drift(1) 0];
    term_rot_coupling = (F_T / p.m) * R * omega_dot_drift_skew * e3;
    
    l_pos = term_coriolis + term_centrifugal + term_rot_coupling;
    
    l_vec = [l_pos; l_psi];
    
    %% Solve for extended inputs
    
    % Check singularity
    %if abs(F_T) < 1e-3
    %    v = zeros(4,1); 
    %else
    v = J_mat \ (nu - l_vec);
    %end
    
    F_T_ddot_cmd = v(1);
    tau_cmd = v(2:4);
    
    %% Physical limits (Saturation)
    %MAX_THRUST = 1.2 * p.m * p.g;
    %MIN_THRUST = 0.5 * p.m * p.g; 
    %MAX_TORQUE = 0.05;
    
    %F_T_saturated = max(MIN_THRUST, min(MAX_THRUST, F_T));
    %tau_saturated = max(-MAX_TORQUE, min(MAX_TORQUE, tau_cmd));

    %% Plant dynamics integration
    
    % Re-calculate dynamics with saturated inputs
    F_thrust_b_sat = [0; 0; F_T_saturated];
    F_tot_b_sat = F_thrust_b_sat + F_drag_b + F_gravity_b;
    
    tau_tot_b = tau_saturated + tau_drag;
    
    V_b_dot_final = (1/p.m) * F_tot_b_sat - cross(omega, V_b);
    omega_dot_final = p.invI * (tau_tot_b - gyro);
    
    dxi_ext = [P_dot; V_b_dot_final; Theta_dot_current; omega_dot_final; F_T_dot; F_T_ddot_cmd];
end